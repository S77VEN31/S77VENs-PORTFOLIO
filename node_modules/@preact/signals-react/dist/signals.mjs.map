{"version":3,"file":"signals.mjs","sources":["../src/index.ts"],"sourcesContent":["import {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tComponent,\n\ttype FunctionComponent,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n} from \"@preact/signals-core\";\nimport type { Effect, JsxRuntimeModule } from \"./internal\";\n\nexport { signal, computed, batch, effect, Signal, type ReadonlySignal };\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactMemoType = Symbol.for(\"react.memo\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L30\nconst ProxyInstance = new WeakMap<\n\tFunctionComponent<any>,\n\tFunctionComponent<any>\n>();\nconst SupportsProxy = typeof Proxy === \"function\";\n\nconst ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components.\n\t * When this is called, we know it means React did run 'Component()',\n\t * that means we can use any hooks here to setup our effect and store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will\n\t * be forwarded to the target Component, so we don't need to copy the Component's\n\t * own or inherited properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\tconst store = useMemo(createEffectStore, Empty);\n\n\t\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\n\t\tconst stop = store.updater._start();\n\n\t\ttry {\n\t\t\tconst children = Component.apply(thisArg, argumentsList);\n\t\t\treturn children;\n\t\t} catch (e) {\n\t\t\t// Re-throwing promises that'll be handled by suspense\n\t\t\t// or an actual error.\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Stop effects in either case before return or throw,\n\t\t\t// Otherwise the effect will leak.\n\t\t\tstop();\n\t\t}\n\t},\n};\n\nfunction ProxyFunctionalComponent(Component: FunctionComponent<any>) {\n\treturn ProxyInstance.get(Component) || WrapWithProxy(Component);\n}\nfunction WrapWithProxy(Component: FunctionComponent<any>) {\n\tif (SupportsProxy) {\n\t\tconst ProxyComponent = new Proxy(Component, ProxyHandlers);\n\n\t\tProxyInstance.set(Component, ProxyComponent);\n\t\tProxyInstance.set(ProxyComponent, ProxyComponent);\n\n\t\treturn ProxyComponent;\n\t}\n\n\t/**\n\t * Emulate a Proxy if environment doesn't support it.\n\t *\n\t * @TODO - unlike Proxy, it's not possible to access the type/Component's\n\t * static properties this way. Not sure if we want to copy all statics here.\n\t * Omitting this for now.\n\t *\n\t * @example - works with Proxy, doesn't with wrapped function.\n\t * ```\n\t * const el = <SomeFunctionalComponent />\n\t * el.type.someOwnOrInheritedProperty;\n\t * el.type.defaultProps;\n\t * ```\n\t */\n\tconst WrappedComponent = function () {\n\t\treturn ProxyHandlers.apply(Component, undefined, arguments);\n\t};\n\tProxyInstance.set(Component, WrappedComponent);\n\tProxyInstance.set(WrappedComponent, WrappedComponent);\n\n\treturn WrappedComponent;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the `effect._callback' is called,\n * we update our store version and tell React to re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore\n * @see https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n */\nfunction createEffectStore() {\n\tlet updater!: Effect;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\tupdater,\n\t\tsubscribe(onStoreChange: () => void) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t};\n}\n\nfunction WrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"function\" && !(type instanceof Component)) {\n\t\t\treturn jsx.call(jsx, ProxyFunctionalComponent(type), props, ...rest);\n\t\t}\n\n\t\tif (type && typeof type === \"object\" && type.$$typeof === ReactMemoType) {\n\t\t\ttype.type = ProxyFunctionalComponent(type.type);\n\t\t\treturn jsx.call(jsx, type, props, ...rest);\n\t\t}\n\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst JsxPro: JsxRuntimeModule = jsxRuntime;\nconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n/**\n * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n * so we need to wrap it regardless.\n *\n * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n * include both, so one of them will be set with `undefined` values.\n */\nReact.createElement = WrapJsx(React.createElement);\nJsxDev.jsx && /*   */ (JsxDev.jsx = WrapJsx(JsxDev.jsx));\nJsxPro.jsx && /*   */ (JsxPro.jsx = WrapJsx(JsxPro.jsx));\nJsxDev.jsxs && /*  */ (JsxDev.jsxs = WrapJsx(JsxDev.jsxs));\nJsxPro.jsxs && /*  */ (JsxPro.jsxs = WrapJsx(JsxPro.jsxs));\nJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = WrapJsx(JsxDev.jsxDEV));\nJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = WrapJsx(JsxPro.jsxDEV));\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node.\n */\nfunction Text({ data }: { data: Signal }) {\n\treturn data.value;\n}\n\n// Decorate Signals so React renders them as <Text> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: ProxyFunctionalComponent(Text) },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, Empty);\n}\n"],"names":["React","Component","useMemo","useRef","useEffect","jsxRuntime","jsxRuntimeDev","useSyncExternalStore","Signal","signal","computed","effect","batch","Empty","Symbol","for","ReactMemoType","ProxyInstance","WeakMap","SupportsProxy","Proxy","ProxyHandlers","apply","thisArg","argumentsList","createEffectStore","store","subscribe","getSnapshot","updater","_start","e","stop","ProxyFunctionalComponent","get","set","ProxyComponent","WrappedComponent","undefined","arguments","WrapWithProxy","onChangeNotifyReact","version","unsubscribe","this","_callback","onStoreChange","WrapJsx","jsx","type","props","rest","call","$$typeof","i","v","value","JsxPro","JsxDev","createElement","jsxs","jsxDEV","Object","defineProperties","prototype","configurable","ReactElemType","data","ref","useSignal","useComputed","compute","$compute","current","useSignalEffect","cb","callback"],"mappings":"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"}